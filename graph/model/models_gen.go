// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type ContactInput struct {
	Name    string  `json:"name"`
	Address *string `json:"address"`
}

type ContactsConnection struct {
	Nodes      []*Contact `json:"nodes"`
	TotalCount int        `json:"totalCount"`
}

type CostClaimsConnection struct {
	Nodes      []*CostClaim `json:"nodes"`
	TotalCount int          `json:"totalCount"`
}

type CostPoolInput struct {
	Name   string  `json:"name"`
	Budget float64 `json:"budget"`
}

type CostPoolsConnection struct {
	Nodes      []*CostPool `json:"nodes"`
	TotalCount int         `json:"totalCount"`
}

type InvoiceRowInput struct {
	ID          *string `json:"id"`
	CostPool    string  `json:"costPool"`
	Description string  `json:"description"`
	Amount      float64 `json:"amount"`
}

type PurchaseInvoiceInput struct {
	Sender      string  `json:"sender"`
	Description string  `json:"description"`
	DueDate     string  `json:"dueDate"`
	Details     *string `json:"details"`
}

type PurchaseInvoicesConnection struct {
	Nodes      []*PurchaseInvoice `json:"nodes"`
	TotalCount int                `json:"totalCount"`
}

type Receipt struct {
	ID         string  `json:"id"`
	Attachment string  `json:"attachment"`
	Amount     float64 `json:"amount"`
	Date       string  `json:"date"`
}

type ReceiptInput struct {
	ID     *string         `json:"id"`
	Date   string          `json:"date"`
	Amount float64         `json:"amount"`
	File   *graphql.Upload `json:"file"`
}

type SalesInvoiceInput struct {
	Recipient      string  `json:"recipient"`
	Date           string  `json:"date"`
	DueDate        string  `json:"dueDate"`
	Details        *string `json:"details"`
	PayerReference *string `json:"payerReference"`
	ContactPerson  *string `json:"contactPerson"`
}

type SalesInvoicesConnection struct {
	Nodes      []*SalesInvoice `json:"nodes"`
	TotalCount int             `json:"totalCount"`
}

type SettingsInput struct {
	Name        string          `json:"name"`
	Email       string          `json:"email"`
	Position    string          `json:"position"`
	Signature   *graphql.Upload `json:"signature"`
	NewPassword *string         `json:"newPassword"`
	Phone       string          `json:"phone"`
	Iban        string          `json:"iban"`
}

type SortOptions struct {
	Key   string    `json:"key"`
	Order SortOrder `json:"order"`
}

type SystemInfo struct {
	Database      string `json:"database"`
	ServerVersion string `json:"serverVersion"`
}

type UserInput struct {
	Name     string   `json:"name"`
	Email    string   `json:"email"`
	Role     UserRole `json:"role"`
	Password *string  `json:"password"`
}

type ViewOptions struct {
	Author string `json:"author"`
	Status string `json:"status"`
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SourceOfMoney string

const (
	SourceOfMoneyOwnAccount   SourceOfMoney = "ownAccount"
	SourceOfMoneyOtherAccount SourceOfMoney = "otherAccount"
	SourceOfMoneyCash         SourceOfMoney = "cash"
)

var AllSourceOfMoney = []SourceOfMoney{
	SourceOfMoneyOwnAccount,
	SourceOfMoneyOtherAccount,
	SourceOfMoneyCash,
}

func (e SourceOfMoney) IsValid() bool {
	switch e {
	case SourceOfMoneyOwnAccount, SourceOfMoneyOtherAccount, SourceOfMoneyCash:
		return true
	}
	return false
}

func (e SourceOfMoney) String() string {
	return string(e)
}

func (e *SourceOfMoney) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceOfMoney(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceOfMoney", str)
	}
	return nil
}

func (e SourceOfMoney) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusCreated  Status = "created"
	StatusApproved Status = "approved"
	StatusRejected Status = "rejected"
	StatusPaid     Status = "paid"
)

var AllStatus = []Status{
	StatusCreated,
	StatusApproved,
	StatusRejected,
	StatusPaid,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusCreated, StatusApproved, StatusRejected, StatusPaid:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleBasic UserRole = "basic"
	UserRoleAdmin UserRole = "admin"
	UserRoleRoot  UserRole = "root"
)

var AllUserRole = []UserRole{
	UserRoleBasic,
	UserRoleAdmin,
	UserRoleRoot,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleBasic, UserRoleAdmin, UserRoleRoot:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
